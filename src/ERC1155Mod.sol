// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.15;

/**
 * @title Mint on demand based sto for security token
 * @author Rajat K
 */

import {STOBaseV2} from "./STOBaseV2.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract ERC1155Mod is STOBaseV2, EIP712 {
    /* -------------------------------------------------------------------------- */
    /*                                  Constant                                  */
    /* -------------------------------------------------------------------------- */

    // bytes32 public constant TypeHash =
    //     keccak256(
    //         "Voucher(uint256 tokenAmount,uint256 tokenPrice,uint256 id,uint256 lockinPeriod,address investor,uint256 nonce)"
    //     );
    bytes32 public constant TYPE_HASH =
        0xf970cd2aafd144c136b4d34ca61af7e0fc1e0e6fd1fb7472138801f7fc7ded3f;

    /**
     * @notice Whitelist role will be used to add the signer for the voucher
     */
    // bytes32 public constant WHITELISTED = keccak256("WHITELISTED");
    bytes32 public constant WHITELISTED =
        0xe799c73ff785ac053943f5d98452f7fa0bcf54da67826fc217d6094dec75c5ee;

    /* -------------------------------------------------------------------------- */
    /*                                   Storage                                  */
    /* -------------------------------------------------------------------------- */

    mapping(address => uint256) internal _floorPrice;

    uint public NONCE = 1;

    struct Voucher {
        uint256 tokenAmount;
        uint256 tokenPrice;
        uint256 id;
        uint256 lockinPeriod;
        address investor;
        uint256 nonce;
    }

    /* -------------------------------------------------------------------------- */
    /*                                    ERRORS                                  */
    /* -------------------------------------------------------------------------- */

    error NonWhitelistedSigner(address signer);
    error InvalidNonce(uint256 givenNonce, uint256 currentNonce);
    error InvalidOfferPrice();
    error InvalidVoucherUser(address need, address given);

    /* -------------------------------------------------------------------------- */
    /*                                    EVENT                                   */
    /* -------------------------------------------------------------------------- */

    event VoucherRedeemed(
        uint256 nonce,
        uint256 indexed id,
        address indexed investor
    );
    event FloorPriceUpdated(address indexed signer, uint voucherPrice);
    event NonceUsed(uint256 nonce);

    /**
     * @notice Constructor for the STO
     *  @param _tokensForSale amount of token for the STO.
     *  @param _tokenPrice price of token 1e6 format
     *  @param stableCoin address of payment token
     *  @param _tokenContractAddress adress of the deal token
     *  @param _forwarderAddress address of the forwarder contract
     *  @param domainName type string of the domain name
     *  @param signatureVersion type string of the signature version
     */

    constructor(
        uint256 _tokensForSale,
        uint256 _tokenPrice,
        address stableCoin,
        address _tokenContractAddress,
        address _forwarderAddress,
        address _sender,
        string memory domainName,
        string memory signatureVersion
    )
        STOBaseV2(
            _tokensForSale,
            _tokenPrice,
            stableCoin,
            _tokenContractAddress,
            _forwarderAddress,
            _sender
        )
        EIP712(domainName, signatureVersion)
    {
        _grantRole(DEFAULT_ADMIN_ROLE, _sender);
        _grantRole(WHITELISTED, _sender);
    }

    /* -------------------------------------------------------------------------- */
    /*                              Internal Function                             */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev floor price will check the minimum price for the voucher that a user can offer.
     * @param voucher struct denoting custom parameters for the sales
     * @param _signature signature generated by voucher signer
     */
    function _verify(
        Voucher calldata voucher,
        bytes calldata _signature
    ) internal {
        uint256 nonce = NONCE;
        if (voucher.nonce != nonce) revert InvalidNonce(voucher.nonce, nonce);
        address signer = getSigner(voucher, _signature);
        if (!isWhiteList(signer)) revert NonWhitelistedSigner(signer);
        if (voucher.tokenPrice <= _floorPrice[signer])
            revert InvalidOfferPrice();
        emit NonceUsed(nonce);
        NONCE = nonce + 1;
        emit VoucherRedeemed(nonce, voucher.id, signer);
    }

    function _hashTypedData(
        Voucher calldata voucher
    ) internal view returns (bytes32) {
        bytes32 hash = keccak256(
            abi.encode(
                TYPE_HASH,
                voucher.tokenAmount,
                voucher.tokenPrice,
                voucher.id,
                voucher.lockinPeriod,
                voucher.investor,
                voucher.nonce
            )
        );
        return _hashTypedDataV4(hash);
    }

    /* -------------------------------------------------------------------------- */
    /*                              External Function                             */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev voucher will be used to buy the token
     * @param investmentId id of the investment
     * @param voucherSignature signature generated by voucher signer
     * @param data to be verified by the compliance contract
     */
    function buyWithVoucher(
        Voucher calldata voucher,
        string calldata investmentId,
        bytes calldata voucherSignature,
        bytes calldata data
    ) external nonReentrant returns (bool) {
        address sender = _msgSender();
        if (sender != voucher.investor)
            revert InvalidVoucherUser(sender, voucher.investor);
        _beforeTokenPurchase(
            voucher.tokenAmount,
            voucher.investor,
            investmentId
        );
        _verify(voucher, voucherSignature);
        _transferStableCoin(sender, voucher.tokenAmount, voucher.tokenPrice);
        _tokenSettlement(
            voucher.investor,
            voucher.tokenAmount,
            voucher.lockinPeriod,
            voucher.id,
            InvestmentType.StableCoin,
            investmentId,
            data
        );
        return true;
    }

    /**
     * @notice Retrieves the signer address from a given voucher and signature.
     * @dev Hashes the voucher data and uses ECDSA to recover the signer's address from the signature.
     * @param voucher The voucher data containing the information to be hashed.
     * @param signature The signature to be used for recovering the signer's address.
     * @return The address of the signer.
     */
    function getSigner(
        Voucher calldata voucher,
        bytes calldata signature
    ) public view returns (address) {
        bytes32 digest = _hashTypedData(voucher);
        return ECDSA.recover(digest, signature);
    }

    /**
     * @notice Checks if an account is whitelisted.
     * @param account The address of the account to check.
     * @return True if the account is whitelisted, otherwise false.
     */

    function isWhiteList(address account) public view returns (bool) {
        return hasRole(WHITELISTED, account);
    }

    /**
     * @notice Adds an account to the whitelist.
     * @dev Allow a signer to add a whitelisted agent throught which agent can issue a voucher.
     * @param account The address of the account to add to the whitelist.
     */

    function addWhiteList(
        address account
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(WHITELISTED, account);
        emit RoleGranted(WHITELISTED, account, msg.sender);
    }

    /**
     * @notice Removes an account from the whitelist.
     * @dev Revokes the WHITELISTED role for an agent.
     * @param account The address of the account to remove from the whitelist.
     */
    function removeWhitelist(
        address account
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _revokeRole(WHITELISTED, account);
    emit RoleRevoked(WHITELISTED, account, msg.sender);
    }

    /**
     * @notice Transfers tokens to an investor.
     * @dev track the tokens bought by the investor and mint tokens directly to the investor..
     * @param amount The amount of tokens to transfer to the investor.
     * @param id The ID associated with the token being transferred.
     * @param data signature for compliTo.
     * @param account The address of the investor receiving the tokens.
     * @return True if the tokens were successfully transferred.
     */

    function _transferTokensToInvestor(
        address account,
        uint id,
        uint256 amount,
        bytes calldata data
    ) internal virtual override returns (bool) {
        tokensBought[account] = tokensBought[account] + amount;
        tokensForSale = tokensForSale - amount;
        _tokenContract.mint(account, id, amount, data);
        return true;
    }

    /**
     * @param signer address of the voucher signer
     */
    function getFloorPrice(address signer) external view returns (uint256) {
        return _floorPrice[signer];
    }

    /**
     * @notice Sets the floor price for a specified signer.
     * @dev the min price at which an agent can sell the token for.
     * @param signer The address of the signer for whom the floor price is being set.
     * @param price The new floor price to be set for the signer..
     */
    function setFloorPrice(
        address signer,
        uint price
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _floorPrice[signer] = price;
        emit FloorPriceUpdated(signer, price);
    }

    function getTotalTokenSold() external view override returns (uint256) {
        return totalTokensForSale - tokenAvailableForSale();
    }

    /**
     * @notice  get the token balance of the contract which user can
     */
    function tokenAvailableForSale() public view override returns (uint256) {
        return tokensForSale;
    }

    function version() external pure override returns (string memory) {
        return "0.2.1";
    }
}
